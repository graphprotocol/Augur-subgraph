# Unused Events - Approval, Transfer (ERC20)
# Events not stored - EscapeHatchChanged, TimestampSet, 

# Events - MarketCreated, ReportingParticipantDisavowed, MarketFinalized, MarketMigrated, MarketMailboxTransferred, MarketParticipantsDisavowed, MarketTransferred, CompleteSetPurchase, CompleteSetSold,  TradingProceedsClaimed

type Market @entity {
    # event MarketCreated 
    id: ID! # address market
    topic: Bytes!
    description: String # I think its not required
    extraInfo: String 
    universe: Bytes! # an address
    marketCreator: Bytes!
    outcomes: [Bytes!]! 
    marketCreationFee: BigInt
    minPrice: BigInt
    maxPrice: BigInt
    marketType: String!

    # event ReportingParticipantDisavowed
    reportingParticipantDisavowed: [Bytes!]! # QUESTION: , not clear if this is an array of participants or only one participant. I would assume it's one but will need to double check 

    # event MarketParticipantDisavowed
    marketParticipantsDisavowed: Boolean # the dispute crowdsourcers for a market in a universe have been disavowed

    # event MarketFinalized
    finalized: Boolean 

    # event MarketMigrated
    migrated: Bytes

    # event MarketTransferred
    marketOwners: [Bytes!]! # QUESTION: how does this work? need to test live with array

    # event MarketMailboxTransferred
    marketMailboxOwners: [Bytes!]! # QUESTION: how does this work? need to test live with array

    # event CompleteSetPurchase
    completeSetPurchasers: [Bytes!]!
    numCompleteSetsPurchase: [BigInt!]!

    # event CompleteSetSold
    completeSetSellers: [Bytes!]!
    numCompleteSetsSold: [BigInt!]!

    # event TradingProceedsClaimed
    tradingProceedsClaimed: [ClaimedTradingProceed!]! @derivedFrom(field: "id")
    initialReports: [InitialReport!]! @derivedFrom(field:"id")
    disputeCrowdsourcer: [DisputeCrowdsourcer!]! @derivedFrom(field: "id")
}

# Events - InitialReportSubmitted, InitialReporterRedeemed, InitialReporterTransferred
type InitialReport @entity {
    # event InitialReportSubmitted
    id: ID! # address market
    universe: Bytes!
    amountStaked: BigInt!
    isDesignatedReported: Boolean # false null bug, no !
    payoutNumerators: [BigInt!]!
    invalid: Boolean

    reporter: Bytes! # ONLY FIELD EDITED BY InitialReporterTransferred -

    #event InitialReporterRedeemed 
    amountRedeemed: BigInt
    repReceived: BigInt
    reportingFeesReceived: BigInt
}

# Events - DisputeCrowdsourcerCompleted, DisputeCrowdsourcerContribution, DisputeCrowdsourcerCreated, DisputeCrowdSourcerRedeemed
type DisputeCrowdsourcer @entity {
    # event DisputeCrowdsourcerCreated
    id: ID! # address market
    universe: Bytes!
    disputeCrowdsourcer: Bytes!
    payoutNumerators: [BigInt!]!
    size: BigInt
    invalid: Boolean

    # event DisputeCrowdsourcerContribution
    # Each element in these two arrays represents one contribution, i.e. all 0 elements are from the same event, and so on
    reporters: [Bytes!]!
    amountStaked: [BigInt!]!

    # event DisputeCrowdsourcerCompleted
    completed: Boolean # this gets triggered true when event Completed is done 

    # event DisputeCrowdsourcedRedeemed
    amountRedeemed: [BigInt!]! #event Redeemed
    repReceived: [BigInt!]! #event Redeemed
    reportingFeesReceived: [BigInt!]!
}

# Events - UniverseCreated, UniverseForked
type Universe @entity {
    id: ID! # universe ID
    parentUniverse: Bytes! # genesis universe does not have a parent
    payoutNumerators: [BigInt!]! # QUESTION: how does this fit in here, from event UniverseCreated . test live 
    forked: Boolean # QUESTION: is this relevant? From event UniverseForked test live
    invalid: Boolean
}

# Events - OrderCanceled, OrderCreated, OrderFilled,
# note - I find it weird that there is no way to connect orders to a market
type Order @entity {
    # event OrderCreated
    id: ID! # orderID
    orderType: String! # bid or asked, derived from the enum
    amount: BigInt!
    price: BigInt!
    creator: Bytes!
    moneyEscrowed: BigInt!
    sharesEscrowed: BigInt!
    tradeGroupIDCreator: Bytes!
    universe: Bytes!
    shareToken: Bytes!

    # event OrderCanceled
    canceller: Bytes
    tokenRefund: BigInt
    sharesRefund: BigInt

    # event OrderFilled
    # QUESTION: - it might be possible to make MULTIPLE order fills, as you can half fill. I need to confirm but for now I am assuming arrays 
    filler: [Bytes!]!
    numCreatorShares: [BigInt!]!
    numCreatorTokens: [BigInt!]!
    numFillerShares: [BigInt!]!
    numFillerTokens: [BigInt!]!
    marketCreatorFees: [BigInt!]!
    reporterFees: [BigInt!]!
    amountFilled: [BigInt!]!
    tradeGroupIDFilled: [Bytes!]!
}

# event TradingProceedsClaimed (also used in Market)
# QUESTION - does this belong back to the market? i.e. should it be an entity relationship, or put directly in there. I assume this is correct right now . so adding it in
type ClaimedTradingProceed @entity {
    id: ID! # market
    universe: Bytes!
    shareToken: Bytes!
    sender: Bytes!
    numShares: BigInt!
    numPayoutTokens: BigInt!
    finalTokenBalance: BigInt
}

# instantiated by TokenMinted
# event TokenMinted, TokenBurned, TokenTransferred
type Token @entity {
    id: ID! # token Address
    universe: Bytes!
    market: Bytes!
    tokenType: String! # derived from enum
    owners: [TokenOwner!]! @derivedFrom(field: "tokenAddress")
}

type TokenOwner @entity {
    id: ID! # concatenation of token address and owner
    tokenAddress: Bytes!
    amount: BigInt!
}


# event DisputeWindowCreated
type DisputeWindow @entity {
    id: ID! # id
    universe: Bytes!
    startTime: BigInt!
    endTime: BigInt!
    disputeWindow: Bytes!
}

# TODO: user should be created and searched up in any interaction with the contracts 
type User @entity {
    id: ID! # user account
    # completeSetsPurchased: TODO, not sure if i need. no , it isnt what i thought. keeping it in the Market
    # completeSetsSold: TODO, not sure if i need. no , it isnt what i thought. keeping it in the Market




